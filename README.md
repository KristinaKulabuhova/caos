## Сигналы
**Сигнал** - это механизм (межпроцессорного взаимодействия) передачи коротких сообщений (номер сигнала), как правило, прерывающий работу процесса, которому он был отправлен.

**Процесс** - некоторая сущность, которая обладает своей выделенной виртуальной памятью. Процесс запускается с помощью системного вызова fork.
Завершение работы процессора:

* Добровольное:
  - выход из функции main
  - вызоы функции exit
  - системный вызов -exit
 
 (Подходит для детерминированного выполнения: у программы есть начало и конец)
 
* Принудительное - отправкой сигнала:
  - команда *kill*
  - команда *killall*
  - запуск через *timeout*
  - выключение или перезагрузка
  - закрытие вкладки терминала
  - кнопочки Ctrl+C

Из-за чего возникают сигналы:
1. Нарушение сигментации
2. запись в закрытый канал или сокет
3. деление на ноль
4. недопустимая инструкция
5. нарушение assertion

Сигналы могут быть посланы процессу:

* ядром, как правило, в случае критической ошибки выполнения;
* другим процессом, если есть у него права (запущены из одного пользователя, либо пользователь root);
* самому себе.

Номера сигналов начинаются с 1. Значение 0 имеет специальное назначение (см. ниже про `kill`). Некоторым номерам сигналов соответствуют стандартные для `POSIX` названия и назначения, которые подробно описаны man `7 signal`.

При получении сигнала процесс может:

* Игнорировать его. Это возможно для всех сигналов, кроме `SIGSTOP` и `SIGKILL`.
* Обработать отдельной функцией. Кроме `SIGSTOP` и `SIGKILL`
* Выполнить действие по умолчанию, предусмотренное назначением стандартного сигнала POSIX. Как правило, это завершение работы процесса.
* Изменить состояние: sTopped | Running

По умолчанию, все сигналы, кроме `SIGCHILD` (информирование о завершении дочернего процесса) и `SIGURG` (информировании о поступлении TCP-сегмента с приоритетными данными), приводят к завершению работы процесса.

Если процесс был завершён с помощью сигнала, а не с ипользованием системного вызова `exit` то для него считается не определенным код возврата. Родительский процесс может отследить эту ситуацию, используюя макросы `WIFSIGNALED` и `WTERMSIG`
```
pid_t child = ...
...
int status;
waitpid(child, &status, 0);
if (WIFEXITED(status)) {
    // дочерний процесс был завершён через exit
    int code = WEXITSTATUS(status); // код возврата
}
if (WIFSIGNALED(status)) {
    // дочерний процесс был завершёл сигналом
    int signum = WTERMSIG(status); // номер сигнала
}
```
Отправить сигнал любому процессу можно с помощью команды `kill` По умолчанию отправляется сигнал `SIGTERM` но можно указать в качестве опции, какой именно сигнал нужно отправить. Кроме того, некоторые сигналы отправляются терминалом, например *Ctrl+C* посылает сигнал `SIGINT` а Ctrl+\ - сигнал `SIGQUIT`

Сигналы:
|  Номер  |  Имя   | По умолчанию  |     Описание     |
| :---:   | :----: | :-----------: | :--------------: |
|    1    | SIGHUP |     Term      | обрыв соединения |
|    2    | SIGINT |     Term      |      Ctrl+C      |
|    3    | SIGQUIT|     Core      |      Ctrl+\      |
|    4    | SIGILL |     Core      | плохая инструкция (посылается ядром)|
|    6    | SIGABRT|     Core      |     abort()      |
|    9    | SIGKILL|     Term      |     убийство     |
|    11   | SIGSEGV|     Core      |что-то плохое с памятью|
|    13   | SIGPIPE|     Term      |Broken pipe|
|    15   | SIGTERM|     Term      |завершение работы (можно перехватить)|
|    17   | SIGCHILD|     Ign      |заверение доч. процесса|
|    18   | SIGCONT|     Cont      |Команда fg -возобновление процесса|
|    19   | SIGSTOP|     Stop      |Ctrl+Z|
|    23   | SIGURG|     Ign      |Socket urgent data|

### Пользовательские сигналы
Изначально в POSIX было зарезервировано два номера сигнала, которые можно было использовать на умотрение пользователя: `SIGUSR1` и `SIGUSR2`.

Кроме того, в Linux предусмотрен диапазон сигналов с номерами от `SIGRTMIN` до `SIGRTMAX`, которые можно использовать на усмотрение пользователя.

Действием по умолчанию для всех "пользовательских" сигналов является завершение работы процесса.

### Отправка сигналов программным способом
#### Системный вызов `kill`
По аналогии с одноимённой командой, kill предназначен для отправки сигнала любому процессу.
```
int kill(pid_t pid, int signum); // возврашает 0 или -1, если ошибка
```
Отправлять сигналы можно только тем процессам, которые принадлежат тому пользователю, что и пользователь, по которым выполняется системный вызов `kill`. Исключение составляет пользователь `root`, который может всё. При попытке отправить сигнал процессу другого пользователя, `kill` вернёт значение `-1`.

Номер процесса может быть меньше `1` в случаях:

* `0` - отправить сигнал всем процессам текущей группы процессов;
* `-1` - отправить сигнал всем процессам пользователя (использовать с осторожностью!);
* отрицательное значение -PID - отправить сигнал всем процессам группы PID.
Номер сигнала может принимать значение `0`, - в этом случае никакой сигнал не будет отправлен, а `kill` вернёт значение `0` в том случае, если процесс (группа) с указанным `pid` существует, и есть права на отправку сигналов.

### Функции `raise` и `abort`
Функция `raise` предназначен для отправки сигнала процессом самому себе. Функция стандартной библиотеки `abort` посылает самому себе сигнал `SIGABRT`, и часто используется для генерации исключительных ситуаций, которые получилось диагностировать во время выполнения, например, функцией `assert`.

### Системный вызов `alarm`
Системный вызов `alarm` запускает таймер, по истечении которого процесс сам себе отправит сигнал `SIGALRM`.
```
unsigned int alarm(unsigned int seconds);
```
Отменить ранее установленный таймер можно, вызвав `alarm` с параметром `0`. Возвращаемым значением является количество секунд предыдущего установленного таймера.

### Обработка сигналов
Сигналы, которые можно перехватить, то есть все, кроме `SIGSTOP` и `SIGKILL`, можно обработать программным способом. Для этого необходимо зарегистрировать функцию-обработчик сигнала.

### Системный вызов `signal`
```
#include <signal.h>

// Этот тип определен только в Linux!
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler); // для Linux
void (*signal(int signum, void (*func)(int))) (int); // по стандарту POSIX
```

```
void handler(int signum) {
  ...
}

int main() {
  signal(SIGINT, handler);
}
```
Системный вызов `signal` предназначен для того, чтобы зарегистрировать функцию в качестве обработчика определенного сигнала. Первым аргументом является номер сигнала, вторым - указатель на функцию, которая принимает единственный аргумент - номер пришедшего сигнала (т.е. одну функцию можно использовать сразу для нескольких сигналов), и ничего не возвращает.

Два специальных значения функции-обработчика `SIG_DFL` и `SIG_IGN` предназанчены для указания обработчика по умолчанию (т.е. отмены ранее зарегистрированного обработчика) и установки игнорирования сигнала.

Системный вызов `signal` возвращает указатель на ранее установленный обработчик.

### Отличия BSD от System-V:

* В System-V обработчик сигнала выполяется один раз, после чего сбрасывается на обработчик по умолчанию, а в BSD - остается неизменным.
* В BSD обработчик сигнала не будет вызван, если в это время уже выполняется обработчик того же самого сигнала, а в System-V это возможно.
* В System-V блокирующие системные вызовы (например, read) завершают свою работу при поступлении сигнала, а в BSD большинство блокирующих системных вызовов возобновляют свою работу после того, как обработчик сигнала заверщает свою работу.
* 
По этой причине, системный вызов `signal` считается устаревшим, и в новом коде использовать его запрещено, за исключением двух ситуаций:
```
signal(signum, SIG_DFL); // сброс на обработчик по умолчанию
signal(signum, SIG_IGN); // игнорирование сигнала
```

### Системный вызов `sigaction`
Системный вызов `sigaction`, в отличии от `signal`, в качестве второго аргумента принимает не указатель на функцию, а указатель на структуру `struct sigaction`, с которой, помимо указателя на функцию, хранится дополнительная информация, описывающая семантику обработки сигнала. Поведение обработчиков, зарегистрированных с помощью `sigaction`, не зависит от операционной системы.
```
int sigaction(int signum,
              const struct sigaction *restrict act,
              struct sigaction *oldact);
```

```
struct sigaction {
    void      (*sa_handler)(int);
    void      (*sa_sigaction)(int, siginfo_t*, void*);
    sigset_t  sa_mask;
    int       sa_flags;
    void      (*sa_restorer)(void);
};
```
Третьим аргументов является указатель на структуру, описывающую обработчик, который был зарегистрирован для этого. Если эта информация не нужна, то можно передать значение `NULL`.

Основные поля структуры struct sigaction:

* `sa_handler` - указатель на функцию-обработчик с одним аргументом типа `int`, могут быть использованы значения `SIG_DFL` и `SIG_IGN`;
* `sa_flags` - набор флагов, опиывающих поведение обработчика;
* `sa_sigaction` - указатель на функцию-обработчик с тремя параметрами, а не одним (используется, если в флагах присутствует `SA_SIGINFO`).

Некоторые флаги, которые можно передавать в `sa_flags`:

* `SA_RESTART` - продолжать выполнение прерванных системных вызовов (семантика BSD) после завершения обработки сигнала. По умолчанию (если флаг отсутствует) используется семантика System-V.
* `SA_SIGINFO` - вместо функции из sa_handler нужно использовать функцию с тремя параметрами int signum, siginfo_t *info, void *context, которой помимо номера сигнала, передается дополнительная информация (например PID отправителя) и пользовательский контекст.
* `SA_RESETHAND` - после выполнения обработчика сбросить на обработчик по умолчанию (семантика System-V). По умолчанию (если флаг отсутствует) используется семантика BSD.
8 `SA_NODEFER` - при повторном приходе сигнала во время выполени обработчика он будет обработан немедленно (семантика System-V). По умолчанию (если флаг отсутствует) используется семантика BSD.

Ключевое слово `volatite` указывает компилятору, что ни в коем случе нельзя оптимизировать использование переменной.

### Механизм доставки сигналов
С каждым процессом связан аттрибут, который не наследуется при `fork`, - это маска сигналов, ожидающих доставки. Как правило, она представляется внутри системы в виде целого числа, хотя стандартом внутреннее представление не регламентируется. Отдельные биты в этой маске соответствуют отдельным сигналам, которые были отправлены процессу, но ещё не обработаны.

Поскольку одним битом можно закодировать только бинарное значение, то учитывается только сам факт поступления сигнала, но не их количество. Например, это может быть критичным, если сигналы долго не обрабатываются. Таким образом, использовать механизм стандартных сигналов для синхронизации двух процессов - нельзя.

Тот факт, что сигнал оказался в маске ожидающих доставки, ещё не означает, что он будет немедленно обработан. У процесса (или даже у отдельной нити) может существовать маска заблокированных сигналов, которая накладывается на маску ожидающих доставки с помощью поразрядной операции `И-НЕ`.

В отличии от маски ожидающих достаки, маска заблокированных сигналов наследуется при fork.

### Множества сигналов
Множества сигналов описываются типом данных sigset_t, объявленным в заголовочном файле <signal.h>.

Операции над множествами:

* sigemptyset(sigset_t *set) - инициализировать пустое множество;
* sigfillset(sigset_t *set) - инициализировать полное множество;
* sigaddset(sigset_t *set, int signum) - добавить сигнал к множеству;
* sigdelset(sigset_t *set, int signum) - убрать сигнал из множества;
* sigismember(sigset_t *set, int signum) - проверить наличие сигнала в множестве.


### Блокровка доставки сигналов

Временная блокировка доставки сигналов часто используется для защиты критических секций программы, когда внезапное выполнение обработчика может повредить целостности данных или нарушению логики поведения.

При этом, нельзя заблокировать сигналы `SIGSTOP` и `SIGKILL`.
Блокировка реализуется установки маски блокируемых сигналов с помощью системного вызова `sigprocmask`:
```
int sigprocmask(int how, sigset_t *set, sigset_t *old_set);
```
где `old_set` - куда записать старую маску (может быть `NULL`, если не интересно), а параметр how - это одно из значений:

* SIG_SETMASK - установить множество сигналов в качестве маски блокируемых сигналов;
* SIG_BLOCK - добавить множество к маске блокируемых сигналов;
* SIG_UNBLOCK - убрать множество из маски блокируемых сигналов.

### Отложенная обработка сигналов
Сигналы, которые попали в маску сигналов, ожидающих доставки, остаются там до тех пор, пока не будут доставлены (а в дальнейшем - либо игнорированы, либо обработаны). Если сигнал был заблокирован, то его обработчик будет вызван сразу после разблокировки.
```
#include <signal.h>
#include <unistd.h>

static void
handler(int signum) {
    static const char Message[] = "Got Ctrl+C\n";
    write(1, Message, sizeof(Message)-1);
}

int main() {
    sigaction(SIGINT,
              &(struct sigaction)
              {.sa_handler=handler, .sa_flags=SA_RESTART},
              NULL);
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);

    while (1) {
        sigprocmask(SIG_BLOCK, &mask, NULL);
        sleep(10);
        sigprocmask(SIG_UNBLOCK, &mask, NULL);
    }
}
```
В данном примере sigprocmask.c обработчик сигнала `SIGINT` всё равно будет выполнен, даже несмотря на длительную паузу.

### Временная замена маски заблокированных сигналов
Маска сигналов может быть временно заменена.

### Системный вызов `sigsuspend`
Системный вызов `sigsuspend(sigset_t *temp_mask)` временно приостанавливает работу программы до тех пор, пока не прийдёт один из сигналов, отсутсвующий в множестве `temp_mask`. Сигналы, отсутсвующие в новом временном множестве, будут доставлены даже в том случае, если они ранее были заблокированы.

Сразу после завершения работы `sigsuspend`, маска заблокированных сигналов вернется в исходную.

### Во время обработки сигнала, зарегистрированного `sigaction`
Одно из полей структуры `sigaction` определяет маску сигналов, доставка которых будет заблокирована на время выполнения обработчика. Дополнительные флаги при этом не требуются.
```
struct sigaction act;
memset(&act, 0, sizeof(act));
act.sa_handler = handler;
act.sa_flags = SA_RESTART;
sigfillset(&act.sa_mask); // блокировать все сигналы
```

### Сигналы реального времени
Сигналы реального времени - это расширение POSIX, которые, в отличии от стандартных UNIX-сигналов могут быть обработаны используя очередь доставки, и таким образом:

учитывается их количество и порядок прихода;
вместе с сигналом сохраняется дополнительная метаинформация, включая одно челочисленное поле, которое может быть использовано произвольным образом.
Сигналы реального времени задаются значениями от `SIGRTMIN` до `SIGRTMAX`, и могут быть использованы с помощью `kill` как дополнительные стандартные UNIX-сигналы. Действие по умолчанию аналогично `SIGTERM`.

Для использования очереди сигналов, необходимо отправлять их с помощью функции `sigqueue`:
```
#include <signal.h>
union sigval {
    int    sival_int;
    void*  sival_ptr;
};
int sigqueue(pid_t pid, int signum, const union sigval value);
```
Эта функция может завершиться с ошибкой `EAGAIN` в том случае, если исчерпан лимит на количество сигналов в очереди. Опциональное значение, передаваемое в качестве третьего параметра, может быть извлечено получателем из поля `si_value` структуры `siginfo_t`, если использовать вариант обработчика `sigaction` с тремя аргументами.

Про маски
Есть маски:
* SigPending 000000010001
* SigBlock   011100000000
* SigIgnor   010000100001

---

# Взаимодействие с каналами и сокетами

### Дублирование файловых дескрипторов
Системный вызов `fcntl` позволяет настраивать различные манипуляции над открытыми файловыми дескрипторами. Одной из команд манипуляции является `F_DUPFD` - создание копии дескриптора в текущем процессе, но с другим номером.

Копия подразумевает, что два разных файловых дескриптора связаны с одним открытым файлом в процессе, и разделяют следующие его аттрибуты:

* сам файловый объект;
* блокировки, связанные с файлом;
* текущая позиция файла;
* режим открытия (чтение/запись/добавление).

При этом, не сохраняется флаг `CLOEXEC`, который предпиывает автоматическое закрытие файла при выполнении системного вызова `exec`.

Упрощённой семантикой для создания копии файловых дескрипторов являются системные вызовы POSIX: `dup` и `dup2`:
```
#include <unistd.h>

/* Возвращает копию нового файлового дескриптора, при этом, по аналогии
   с open, численное значение нового файлового дескриптора - минимальный
   не занятый номер. */
int dup(int old_fd);

/* Создаёт копию нового файлового дескриптора с явно указанным номером new_fd.
   Если ранее файловый дескриптор new_fd был открыт, то закрывает его. */
int dup2(int old_fd, int new_fd);
```
### Неименованные каналы
Канал - это пара связанных между собой файловых дескрипторов, один из которых предназначен для только для чтения, а другой - только для записи.

Канал создается с помощью системного вызова pipe:
```
#include <unistd.h>

int pipe(int pipefd[2]);
```
В качестве аргумента системному вызову `pipe` передается указатель на массив и двух целых чисел, куда будут записаны номера файловых дескрипторов:

* `pipefd[0]` - файловый дескриптор, предназначенный для чтения;
* `pipefd[1]` - файловый дескриптор, предназначенный для записи.

### Запись данных в канал
Осуществляется с помощью системного вызова `write`, первым аргументом которого является `pipefd[1]`. Канал является буферизованным, под Linux обычно его размер 65К. Возможные сценарии поведения при записи:

* системный вызов `write` завершается немедленно, если размер данных меньше размера буфера, и в буфере есть место;
* системный вызов `write` приостанавливает выполнение до тех пор, пока не появится место в буфере, то есть предыдущие данные не будут кем-то прочитаны из канала;
* системный вызов `write` завершается с ошибкой `Broken pipe` (доставляется через сигнал `SIGPIPE`), если с противоположной стороны канал был закрыт, и данные читать некому.

### Чтение данных из канала
Осуществляется с помощью системного вызова `read`, первым аргументом которого является `pipefd[0]`. 

Возможные сценарии поведения при чтении:

* если в буфере канала есть данные, то `read` читает их, и завершает свою работу;
* если буфер пустой и есть хотя бы один открытый файловый дескриптор с противоположной стороны, то выполнение `read` блокируется;
* если буфер пустой и все файловые дескрипторы с противоположной стороны каналы закрыты, то `read` немедленно завершает работу, возвращая `0`.

### Проблема dead lock
При выполнении системных вызовов `fork`, `dup` или `dup2` создаются копии файловых дескрипторов, связанных с каналом. Если не закрывать все лишние (неиспользуемые) копии файловых дескрипторов, предназначенных для записи, то это приводит к тому, что при очередной попытке чтения из канала, `read` вместо того, чтобы завершить работу, будет находиться в ожидании данных.
```
int fds_pair[2];
pipe(fds_pair);

if ( 0!=fork() )  // теперь у нас существует неявная копия файловых дескрипторов
{
    // немного записываем в буфер
    static const char Hello[] = "Hello!";
    write(fds_pair[1], Hello, sizeof(Hello));
    close(fds_pair[1]);
    // а теперь читаем обратно
    char buffer[1024];
    read(fds_pair[0], buffer, sizeof(buffer)); // получаем dead lock!
}
else while (1) shched_yield();
```
Для того, чтобы избежать этой проблемы, необходимо тщательно следить за тем, в какие моменты создаются копии файловых дескрипторов, и закрывать их тогда, когда они не нужны.

---

