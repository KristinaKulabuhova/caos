## Сигналы
**Сигнал** - это механизм (межпроцессорного взаимодействия) передачи коротких сообщений (номер сигнала), как правило, прерывающий работу процесса, которому он был отправлен.

**Процесс** - некоторая сущность, которая обладает своей выделенной виртуальной памятью. Процесс запускается с помощью системного вызова fork.
Завершение работы процессора:

* Добровольное:
  - выход из функции main
  - вызоы функции exit
  - системный вызов -exit
 
 (Подходит для детерминированного выполнения: у программы есть начало и конец)
 
* Принудительное - отправкой сигнала:
  - команда *kill*
  - команда *killall*
  - запуск через *timeout*
  - выключение или перезагрузка
  - закрытие вкладки терминала
  - кнопочки Ctrl+C

Из-за чего возникают сигналы:
1. Нарушение сигментации
2. запись в закрытый канал или сокет
3. деление на ноль
4. недопустимая инструкция
5. нарушение assertion

Сигналы могут быть посланы процессу:

* ядром, как правило, в случае критической ошибки выполнения;
* другим процессом, если есть у него права (запущены из одного пользователя, либо пользователь root);
* самому себе.

Номера сигналов начинаются с 1. Значение 0 имеет специальное назначение (см. ниже про `kill`). Некоторым номерам сигналов соответствуют стандартные для `POSIX` названия и назначения, которые подробно описаны man `7 signal`.

При получении сигнала процесс может:

* Игнорировать его. Это возможно для всех сигналов, кроме `SIGSTOP` и `SIGKILL`.
* Обработать отдельной функцией. Кроме `SIGSTOP` и `SIGKILL`
* Выполнить действие по умолчанию, предусмотренное назначением стандартного сигнала POSIX. Как правило, это завершение работы процесса.
* Изменить состояние: sTopped | Running

По умолчанию, все сигналы, кроме `SIGCHILD` (информирование о завершении дочернего процесса) и `SIGURG` (информировании о поступлении TCP-сегмента с приоритетными данными), приводят к завершению работы процесса.

Если процесс был завершён с помощью сигнала, а не с ипользованием системного вызова `exit` то для него считается не определенным код возврата. Родительский процесс может отследить эту ситуацию, используюя макросы `WIFSIGNALED` и `WTERMSIG`
```
pid_t child = ...
...
int status;
waitpid(child, &status, 0);
if (WIFEXITED(status)) {
    // дочерний процесс был завершён через exit
    int code = WEXITSTATUS(status); // код возврата
}
if (WIFSIGNALED(status)) {
    // дочерний процесс был завершёл сигналом
    int signum = WTERMSIG(status); // номер сигнала
}
```
Отправить сигнал любому процессу можно с помощью команды `kill` По умолчанию отправляется сигнал `SIGTERM` но можно указать в качестве опции, какой именно сигнал нужно отправить. Кроме того, некоторые сигналы отправляются терминалом, например *Ctrl+C* посылает сигнал `SIGINT` а Ctrl+\ - сигнал `SIGQUIT`

Сигналы:
|  Номер  |  Имя   | По умолчанию  |     Описание     |
| :---:   | :----: | :-----------: | :--------------: |
|    1    | SIGHUP |     Term      | обрыв соединения |
|    2    | SIGINT |     Term      |      Ctrl+C      |
|    3    | SIGQUIT|     Core      |      Ctrl+\      |
|    4    | SIGILL |     Core      | плохая инструкция (посылается ядром)|
|    6    | SIGABRT|     Core      |     abort()      |
|    9    | SIGKILL|     Term      |     убийство     |
|    11   | SIGSEGV|     Core      |что-то плохое с памятью|
|    13   | SIGPIPE|     Term      |Broken pipe|
|    15   | SIGTERM|     Term      |завершение работы (можно перехватить)|
|    17   | SIGCHILD|     Ign      |заверение доч. процесса|
|    18   | SIGCONT|     Cont      |Команда fg -возобновление процесса|
|    19   | SIGSTOP|     Stop      |Ctrl+Z|
|    23   | SIGURG|     Ign      |Socket urgent data|

### Пользовательские сигналы
Изначально в POSIX было зарезервировано два номера сигнала, которые можно было использовать на умотрение пользователя: `SIGUSR1` и `SIGUSR2`.

Кроме того, в Linux предусмотрен диапазон сигналов с номерами от `SIGRTMIN` до `SIGRTMAX`, которые можно использовать на усмотрение пользователя.

Действием по умолчанию для всех "пользовательских" сигналов является завершение работы процесса.

### Отправка сигналов программным способом
#### Системный вызов `kill`
По аналогии с одноимённой командой, kill предназначен для отправки сигнала любому процессу.
```
int kill(pid_t pid, int signum); // возврашает 0 или -1, если ошибка
```
Отправлять сигналы можно только тем процессам, которые принадлежат тому пользователю, что и пользователь, по которым выполняется системный вызов `kill`. Исключение составляет пользователь `root`, который может всё. При попытке отправить сигнал процессу другого пользователя, `kill` вернёт значение `-1`.

Номер процесса может быть меньше `1` в случаях:

* `0` - отправить сигнал всем процессам текущей группы процессов;
* `-1` - отправить сигнал всем процессам пользователя (использовать с осторожностью!);
* отрицательное значение -PID - отправить сигнал всем процессам группы PID.
Номер сигнала может принимать значение `0`, - в этом случае никакой сигнал не будет отправлен, а `kill` вернёт значение `0` в том случае, если процесс (группа) с указанным `pid` существует, и есть права на отправку сигналов.

### Функции `raise` и `abort`
Функция `raise` предназначен для отправки сигнала процессом самому себе. Функция стандартной библиотеки `abort` посылает самому себе сигнал `SIGABRT`, и часто используется для генерации исключительных ситуаций, которые получилось диагностировать во время выполнения, например, функцией `assert`.

### Системный вызов `alarm`
Системный вызов `alarm` запускает таймер, по истечении которого процесс сам себе отправит сигнал `SIGALRM`.
```
unsigned int alarm(unsigned int seconds);
```
Отменить ранее установленный таймер можно, вызвав `alarm` с параметром `0`. Возвращаемым значением является количество секунд предыдущего установленного таймера.

### Обработка сигналов
Сигналы, которые можно перехватить, то есть все, кроме `SIGSTOP` и `SIGKILL`, можно обработать программным способом. Для этого необходимо зарегистрировать функцию-обработчик сигнала.

### Системный вызов `signal`
```
#include <signal.h>

// Этот тип определен только в Linux!
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler); // для Linux
void (*signal(int signum, void (*func)(int))) (int); // по стандарту POSIX
```

```
void handler(int signum) {
  ...
}

int main() {
  signal(SIGINT, handler);
}
```
Системный вызов `signal` предназначен для того, чтобы зарегистрировать функцию в качестве обработчика определенного сигнала. Первым аргументом является номер сигнала, вторым - указатель на функцию, которая принимает единственный аргумент - номер пришедшего сигнала (т.е. одну функцию можно использовать сразу для нескольких сигналов), и ничего не возвращает.

Два специальных значения функции-обработчика `SIG_DFL` и `SIG_IGN` предназанчены для указания обработчика по умолчанию (т.е. отмены ранее зарегистрированного обработчика) и установки игнорирования сигнала.

Системный вызов `signal` возвращает указатель на ранее установленный обработчик.

### Отличия BSD от System-V:

* В System-V обработчик сигнала выполяется один раз, после чего сбрасывается на обработчик по умолчанию, а в BSD - остается неизменным.
* В BSD обработчик сигнала не будет вызван, если в это время уже выполняется обработчик того же самого сигнала, а в System-V это возможно.
* В System-V блокирующие системные вызовы (например, read) завершают свою работу при поступлении сигнала, а в BSD большинство блокирующих системных вызовов возобновляют свою работу после того, как обработчик сигнала заверщает свою работу.
* 
По этой причине, системный вызов `signal` считается устаревшим, и в новом коде использовать его запрещено, за исключением двух ситуаций:
```
signal(signum, SIG_DFL); // сброс на обработчик по умолчанию
signal(signum, SIG_IGN); // игнорирование сигнала
```

### Системный вызов `sigaction`
Системный вызов `sigaction`, в отличии от `signal`, в качестве второго аргумента принимает не указатель на функцию, а указатель на структуру `struct sigaction`, с которой, помимо указателя на функцию, хранится дополнительная информация, описывающая семантику обработки сигнала. Поведение обработчиков, зарегистрированных с помощью `sigaction`, не зависит от операционной системы.
```
int sigaction(int signum,
              const struct sigaction *restrict act,
              struct sigaction *oldact);
```

```
struct sigaction {
    void      (*sa_handler)(int);
    void      (*sa_sigaction)(int, siginfo_t*, void*);
    sigset_t  sa_mask;
    int       sa_flags;
    void      (*sa_restorer)(void);
};
```
Третьим аргументов является указатель на структуру, описывающую обработчик, который был зарегистрирован для этого. Если эта информация не нужна, то можно передать значение `NULL`.

Основные поля структуры struct sigaction:

* `sa_handler` - указатель на функцию-обработчик с одним аргументом типа `int`, могут быть использованы значения `SIG_DFL` и `SIG_IGN`;
* `sa_flags` - набор флагов, опиывающих поведение обработчика;
* `sa_sigaction` - указатель на функцию-обработчик с тремя параметрами, а не одним (используется, если в флагах присутствует `SA_SIGINFO`).

Некоторые флаги, которые можно передавать в `sa_flags`:

* `SA_RESTART` - продолжать выполнение прерванных системных вызовов (семантика BSD) после завершения обработки сигнала. По умолчанию (если флаг отсутствует) используется семантика System-V.
* `SA_SIGINFO` - вместо функции из sa_handler нужно использовать функцию с тремя параметрами int signum, siginfo_t *info, void *context, которой помимо номера сигнала, передается дополнительная информация (например PID отправителя) и пользовательский контекст.
* `SA_RESETHAND` - после выполнения обработчика сбросить на обработчик по умолчанию (семантика System-V). По умолчанию (если флаг отсутствует) используется семантика BSD.
8 `SA_NODEFER` - при повторном приходе сигнала во время выполени обработчика он будет обработан немедленно (семантика System-V). По умолчанию (если флаг отсутствует) используется семантика BSD.

Ключевое слово `volatite` указывает компилятору, что ни в коем случе нельзя оптимизировать использование переменной.

### Механизм доставки сигналов
С каждым процессом связан аттрибут, который не наследуется при `fork`, - это маска сигналов, ожидающих доставки. Как правило, она представляется внутри системы в виде целого числа, хотя стандартом внутреннее представление не регламентируется. Отдельные биты в этой маске соответствуют отдельным сигналам, которые были отправлены процессу, но ещё не обработаны.

Поскольку одним битом можно закодировать только бинарное значение, то учитывается только сам факт поступления сигнала, но не их количество. Например, это может быть критичным, если сигналы долго не обрабатываются. Таким образом, использовать механизм стандартных сигналов для синхронизации двух процессов - нельзя.

Тот факт, что сигнал оказался в маске ожидающих доставки, ещё не означает, что он будет немедленно обработан. У процесса (или даже у отдельной нити) может существовать маска заблокированных сигналов, которая накладывается на маску ожидающих доставки с помощью поразрядной операции `И-НЕ`.

В отличии от маски ожидающих достаки, маска заблокированных сигналов наследуется при fork.

### Множества сигналов
Множества сигналов описываются типом данных sigset_t, объявленным в заголовочном файле <signal.h>.

Операции над множествами:

* sigemptyset(sigset_t *set) - инициализировать пустое множество;
* sigfillset(sigset_t *set) - инициализировать полное множество;
* sigaddset(sigset_t *set, int signum) - добавить сигнал к множеству;
* sigdelset(sigset_t *set, int signum) - убрать сигнал из множества;
* sigismember(sigset_t *set, int signum) - проверить наличие сигнала в множестве.


### Блокровка доставки сигналов

Временная блокировка доставки сигналов часто используется для защиты критических секций программы, когда внезапное выполнение обработчика может повредить целостности данных или нарушению логики поведения.

При этом, нельзя заблокировать сигналы `SIGSTOP` и `SIGKILL`.
Блокировка реализуется установки маски блокируемых сигналов с помощью системного вызова `sigprocmask`:
```
int sigprocmask(int how, sigset_t *set, sigset_t *old_set);
```
где `old_set` - куда записать старую маску (может быть `NULL`, если не интересно), а параметр how - это одно из значений:

* SIG_SETMASK - установить множество сигналов в качестве маски блокируемых сигналов;
* SIG_BLOCK - добавить множество к маске блокируемых сигналов;
* SIG_UNBLOCK - убрать множество из маски блокируемых сигналов.

### Отложенная обработка сигналов
Сигналы, которые попали в маску сигналов, ожидающих доставки, остаются там до тех пор, пока не будут доставлены (а в дальнейшем - либо игнорированы, либо обработаны). Если сигнал был заблокирован, то его обработчик будет вызван сразу после разблокировки.
```
#include <signal.h>
#include <unistd.h>

static void
handler(int signum) {
    static const char Message[] = "Got Ctrl+C\n";
    write(1, Message, sizeof(Message)-1);
}

int main() {
    sigaction(SIGINT,
              &(struct sigaction)
              {.sa_handler=handler, .sa_flags=SA_RESTART},
              NULL);
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);

    while (1) {
        sigprocmask(SIG_BLOCK, &mask, NULL);
        sleep(10);
        sigprocmask(SIG_UNBLOCK, &mask, NULL);
    }
}
```
В данном примере sigprocmask.c обработчик сигнала `SIGINT` всё равно будет выполнен, даже несмотря на длительную паузу.

### Временная замена маски заблокированных сигналов
Маска сигналов может быть временно заменена.

### Системный вызов `sigsuspend`
Системный вызов `sigsuspend(sigset_t *temp_mask)` временно приостанавливает работу программы до тех пор, пока не прийдёт один из сигналов, отсутсвующий в множестве `temp_mask`. Сигналы, отсутсвующие в новом временном множестве, будут доставлены даже в том случае, если они ранее были заблокированы.

Сразу после завершения работы `sigsuspend`, маска заблокированных сигналов вернется в исходную.

### Во время обработки сигнала, зарегистрированного `sigaction`
Одно из полей структуры `sigaction` определяет маску сигналов, доставка которых будет заблокирована на время выполнения обработчика. Дополнительные флаги при этом не требуются.
```
struct sigaction act;
memset(&act, 0, sizeof(act));
act.sa_handler = handler;
act.sa_flags = SA_RESTART;
sigfillset(&act.sa_mask); // блокировать все сигналы
```

### Сигналы реального времени
Сигналы реального времени - это расширение POSIX, которые, в отличии от стандартных UNIX-сигналов могут быть обработаны используя очередь доставки, и таким образом:

учитывается их количество и порядок прихода;
вместе с сигналом сохраняется дополнительная метаинформация, включая одно челочисленное поле, которое может быть использовано произвольным образом.
Сигналы реального времени задаются значениями от `SIGRTMIN` до `SIGRTMAX`, и могут быть использованы с помощью `kill` как дополнительные стандартные UNIX-сигналы. Действие по умолчанию аналогично `SIGTERM`.

Для использования очереди сигналов, необходимо отправлять их с помощью функции `sigqueue`:
```
#include <signal.h>
union sigval {
    int    sival_int;
    void*  sival_ptr;
};
int sigqueue(pid_t pid, int signum, const union sigval value);
```
Эта функция может завершиться с ошибкой `EAGAIN` в том случае, если исчерпан лимит на количество сигналов в очереди. Опциональное значение, передаваемое в качестве третьего параметра, может быть извлечено получателем из поля `si_value` структуры `siginfo_t`, если использовать вариант обработчика `sigaction` с тремя аргументами.

Про маски
Есть маски:
* SigPending 000000010001
* SigBlock   011100000000
* SigIgnor   010000100001

---

# Взаимодействие с каналами и сокетами

### Дублирование файловых дескрипторов
Системный вызов `fcntl` позволяет настраивать различные манипуляции над открытыми файловыми дескрипторами. Одной из команд манипуляции является `F_DUPFD` - создание копии дескриптора в текущем процессе, но с другим номером.

Копия подразумевает, что два разных файловых дескриптора связаны с одним открытым файлом в процессе, и разделяют следующие его аттрибуты:

* сам файловый объект;
* блокировки, связанные с файлом;
* текущая позиция файла;
* режим открытия (чтение/запись/добавление).

При этом, не сохраняется флаг `CLOEXEC`, который предпиывает автоматическое закрытие файла при выполнении системного вызова `exec`.

Упрощённой семантикой для создания копии файловых дескрипторов являются системные вызовы POSIX: `dup` и `dup2`:
```
#include <unistd.h>

/* Возвращает копию нового файлового дескриптора, при этом, по аналогии
   с open, численное значение нового файлового дескриптора - минимальный
   не занятый номер. */
int dup(int old_fd);

/* Создаёт копию нового файлового дескриптора с явно указанным номером new_fd.
   Если ранее файловый дескриптор new_fd был открыт, то закрывает его. */
int dup2(int old_fd, int new_fd);
```
### Неименованные каналы
Канал - это пара связанных между собой файловых дескрипторов, один из которых предназначен для только для чтения, а другой - только для записи.

Канал создается с помощью системного вызова pipe:
```
#include <unistd.h>

int pipe(int pipefd[2]);
```
В качестве аргумента системному вызову `pipe` передается указатель на массив и двух целых чисел, куда будут записаны номера файловых дескрипторов:

* `pipefd[0]` - файловый дескриптор, предназначенный для чтения;
* `pipefd[1]` - файловый дескриптор, предназначенный для записи.

### Запись данных в канал
Осуществляется с помощью системного вызова `write`, первым аргументом которого является `pipefd[1]`. Канал является буферизованным, под Linux обычно его размер 65К. Возможные сценарии поведения при записи:

* системный вызов `write` завершается немедленно, если размер данных меньше размера буфера, и в буфере есть место;
* системный вызов `write` приостанавливает выполнение до тех пор, пока не появится место в буфере, то есть предыдущие данные не будут кем-то прочитаны из канала;
* системный вызов `write` завершается с ошибкой `Broken pipe` (доставляется через сигнал `SIGPIPE`), если с противоположной стороны канал был закрыт, и данные читать некому.

### Чтение данных из канала
Осуществляется с помощью системного вызова `read`, первым аргументом которого является `pipefd[0]`. 

Возможные сценарии поведения при чтении:

* если в буфере канала есть данные, то `read` читает их, и завершает свою работу;
* если буфер пустой и есть хотя бы один открытый файловый дескриптор с противоположной стороны, то выполнение `read` блокируется;
* если буфер пустой и все файловые дескрипторы с противоположной стороны каналы закрыты, то `read` немедленно завершает работу, возвращая `0`.

### Проблема dead lock
При выполнении системных вызовов `fork`, `dup` или `dup2` создаются копии файловых дескрипторов, связанных с каналом. Если не закрывать все лишние (неиспользуемые) копии файловых дескрипторов, предназначенных для записи, то это приводит к тому, что при очередной попытке чтения из канала, `read` вместо того, чтобы завершить работу, будет находиться в ожидании данных.
```
int fds_pair[2];
pipe(fds_pair);

if ( 0!=fork() )  // теперь у нас существует неявная копия файловых дескрипторов
{
    // немного записываем в буфер
    static const char Hello[] = "Hello!";
    write(fds_pair[1], Hello, sizeof(Hello));
    close(fds_pair[1]);
    // а теперь читаем обратно
    char buffer[1024];
    read(fds_pair[0], buffer, sizeof(buffer)); // получаем dead lock!
}
else while (1) shched_yield();
```
Для того, чтобы избежать этой проблемы, необходимо тщательно следить за тем, в какие моменты создаются копии файловых дескрипторов, и закрывать их тогда, когда они не нужны.

---

### Сокеты с установкой соединения
####Сокет
*Сокет* - это файловый дескриптор, открытый как для чтения, так и для записи. Предназначен для взаимодействия:

* разных процессов, работающих на одном компьютере (хосте);
* разных процессов, работающих на разных хостах.
Создается сокет с помощью системного вызова socket:
```
#include <sys/types.h>
#include <sys/socket.h>

int socket(
  int domain,    // тип пространства имён
  int type,      // тип взаимодействия через сокет
  int protocol   // номер протокола или 0 для авто-выбора
)
```
Механизм сокетов появился ещё в 80-е годы XX века, когда не было единого стандарта для сетевого взаимодействия, и сокеты являлись абстракцией поверх любого механизма сетевого взаимодействия, поддерживая огромное количество разных протоколов.

В современных системах используемыми можно считать несколько механизмов, определяющих пространство имен сокетов; все остальное - это legacy, которое мы дальше рассматривать не будем.

* `AF_UNIX` (man 7 unix) - пространство имен локальных UNIX-сокетов, которые позволяют взаимодействовать разным процессам в пределах одного компьютера, используя в качестве адреса уникальное имя (длиной не более 107 байт) специального файла.
* `AF_INET` (man 7 ip) - пространство кортежей, состоящих из 32-битных IPv4 адресов и 16-битных номеров портов. IP-адрес определяет хост, на котором запущен процесс для взаимодействия, а номер порта связан с конкретным процессом на хосте.
* `AF_INET6` (man 7 ipv6) - аналогично `AF_INET`, но используется 128-разрядная адресация хостов IPv6; пока этот стандарт поддерживается не всеми хостерами и провайдерами сети Интернет.
* `AF_PACKET` (man 7 packet) - взаимодействие на низком уровне.
Через сокеты обычно происходит взаимодействие одним из двух способов (указывается в качестве второго параметра `type`):

* `SOCK_STREAM` - взаимодействие с помощью системных вызовов `read` и `write` как с обычным файловым дескриптором. В случае взаимодействия по сети, здесь подразумевается использование протокола `TCP`.
* `SOCK_DGRAM` - взаимодейтсвие без предвариательной установки взаимодействия для отправки коротких сообщений. В случае взаимодействия по сети, здесь подразумевается использование протокола `UDP`.

### Пара сокетов
Иногда сокеты удобно использовать в качестве механизма взаимодействия между разными потоками или родственными процессами: в отличии от каналов, они являются двусторонними, и кроме того, поддерживают обработку события "закрытие соединения". Пара сокетов создается с помощью системного вызова `socketpair`:
```
int socketpair(
  int domain,    // В Linux поддерживатся только AF_UNIX
  int type,      // SOCK_STREAM или SOCK_DGRAM
  int protocol,  // Только значение 0 в Linux
  int sv[2]      // По аналогии с pipe, массив из двух int
)
```
В отличии от неименованных каналов, которые создаются системным вызовом `pipe`, для пары сокетов не имеет значения, какой элемент массива `sv` использовать для чтения, а какой - для записи, - они являются равноправными.

### Использование сокетов в роли клиента
Сокеты могут участвовать во взаимодействии в одной из двух ролей. Процесс может быть сервером, то есть объявить некоторый адрес (имя файла, или кортеж из IP-адреса и номера порта) для приема входящих соединений, либо выступать в роли клиента, то есть подключиться к какому-то серверу.

Сразу после создания сокета, он ещё не готов к взамиодействию с помощью системных вызовов `read` и `write`. Установка взаимодействия с сервером осуществляется с помощью системного вызова `connect`. После успешного выполнения этого системного вызова - взаимодействие становится возможным до выполнения системного вызова `shutdown`.
```
int connect(
  int sockfd,                  // файловый дескриптор сокета

  const struct sockaddr *addr, // указатель на *абстрактную*
                               // структуру, описывающую
                               // адрес подключения

  socklen_t addrlen            // размер реальной структуры,
                               // которая передается в
                               // качестве второго параметра
)
```
Поскольку язык Си не является объектно-ориентированным, то нужно в качестве адреса передавать:

1. Структуру, первое поле которой содержит целое число со значением, совпадающим с `domain` соответствующего сокета
2. Размер этой структуры.
Конкретными стурктурами, которые "наследуются" от абстрактной структуры `sockaddr` могут быть:

1. Для адресного пространства UNIX - стрктура `sockaddr_un`
```
#include <sys/socket.h>
#include <sys/un.h>

struct sockaddr_un {
  sa_family_t   sun_family;    // нужно записать AF_UNIX
  char          sun_path[108]; // путь к файлу сокета
};
```
2. Для адресации в IPv4 - структура `sockaddr_in`:
```
#include <sys/socket.h>
#include <netinet/in.h>

struct sockaddr_in {
  sa_family_t    sin_family; // нужно записать AF_INET
  in_port_t      sin_port;   // uint16_t номер порта
  struct in_addr sin_addr;   // структура из одного поля:
                             // - in_addr_t s_addr;
                             //   где in_addr_t - это uint32_t
};
```
3. Для адресации в IPv6 - структура `sockaddr_in6`:
```
#include <sys/socket.h>
#include <netinet/in.h>

struct sockaddr_in6 {
  sa_family_t    sin6_family; // нужно записать AF_INET6
  in_port_t      sin6_port;   // uint16_t номер порта
  uint32_t       sin6_flowinfo; // дополнительное поле IPv6
  struct in6_addr sin6_addr;  // структура из одного поля,
                              // объявленного как union {
                              //     uint8_t  [16];2

                              // т.е. размер in6_addr - 128 бит
  uint32_t       sin6_scope_id; // дополнительное поле IPv6
};
```
### Адреса в сети IPv4
Адрес хоста в сети IPv4 - это 32-разрядное беззнаковое целое число в *сетевом порядке байт*, то есть Big-Endian. Для номеров портов - аналогично.

Конвертация порядка байт из сетевого в системный и наоборот осуществляется с помощью одной из функций, объявленных в `<arpa/inet.h>`:

* `uint32_t htonl(uint32_t hostlong)` - 32-битное из системного в сетевой порядок байт;
* `uint32_t ntohl(uint32_t netlong)` - 32-битное из сетевого в системный порядок байт;
* `uint16_t htons(uint16_t hostshort)` - 16-битное из системного в сетевой порядок байт;
* `uint16_t ntohs(uint16_t netshort)` - 16-битное из сетевого в системный порядок байт.

IPv4 адреса обычно записывают в десятичной записи, отделяя каждый байт точкой, например: `192.168.1.1`. Такая запись может быть конвертирована из текста в 32-битный адрес с помощью функций `inet_aton` или `inet_addr`.

### Закрытие сетевого соединения
Системный вызов `close` предназначен для закрытия файлового дескриптора, и его нужно вызывать для того, чтобы освободить запись в таблице файловых дескрипторов. Это является необходимым, но не достаточным требованием при работе с TCP-сокетами.

Помимо закрытия файлового дескриптора, хорошим тоном считается уведомление противоположной стороны о том, что сетевое соединение закрывается

Это уведомление осуществляется с помощью системного вызова shutdown.

### Использование сокетов в роли сервера
Для использования сокета в роли сервера, необходимо выполнить следующие действия:

1. Связать сокет с некоторым адресом. Для этого используется системный вызов `bind`, параметры которого точно такие же, как для системного вызова `connect`. Если на компьютере более одного IP-адреса, то адрес `0.0.0.0` означает "все адреса". Часто при отладке и возникает проблема, что порт с определенным номером уже был занят на предыдущем запуске программы (и, например, не был корректно закрыт). Это решается принудительным повторным использованием адреса:
```
// В релизной сборке такого обычно быть не должно!
#ifdef DEBUG
int val = 1;
setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val));
#endif
```
2. Создать очередь, в которой будут находиться входящие, но ещё не принятые подключения. Это делается с помощью системного вызова `listen`, который принимает в качестве параметра максимальное количество ожидающих подключений. Для Linux это значение равно 128, определено в константе `SOMAXCONN`.

3. Принимать по одному соединению с помощью системного вызова `accept`. Второй и третий параметры этого системного вызова могуть быть `NULL`, если нас не интересует адрес того, кто к нам подключился. Системный вызов `accept` блокирует выполнение до тех пор, пока не появится входящее подключение. После чего - возвращает файловый дескриптор нового сокета, который связан с конкретным клиентом, который к нам подключился.
