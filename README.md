## Сигналы
Сигнал - это механизм (межпроцессорного взаимодействия) передачи коротких сообщений (номер сигнала), как правило, прерывающий работу процесса, которому он был отправлен.

Процесс - некоторая сущность, которая обладает своей выделенной виртуальной памятью. Процесс запускается с помощью системного вызова fork.
Завершение работы процессора:

* Добровольное:
  - выход из функции main
  - вызоы функции exit
  - системный вызов -exit
 
 (Подходит для детерминированного выполнения: у программы есть начало и конец)
 
* Принудительное - отправкой сигнала:
  - команда *kill*
  - команда *killall*
  - запуск через *timeout*
  - выключение или перезагрузка
  - закрытие вкладки терминала
  - кнопочки Ctrl+C

Из-за чего возникают сигналы:
1. Нарушение сигментации
2. запись в закрытый канал или сокет
3. деление на ноль
4. недопустимая инструкция
5. нарушение assertion

Сигналы могут быть посланы процессу:

* ядром, как правило, в случае критической ошибки выполнения;
* другим процессом, если есть у него права (запущены из одного пользователя, либо пользователь root);
* самому себе.

Номера сигналов начинаются с 1. Значение 0 имеет специальное назначение (см. ниже про `kill`). Некоторым номерам сигналов соответствуют стандартные для `POSIX` названия и назначения, которые подробно описаны man `7 signal`.

При получении сигнала процесс может:

* Игнорировать его. Это возможно для всех сигналов, кроме `SIGSTOP` и `SIGKILL`.
* Обработать отдельной функцией. Кроме `SIGSTOP` и `SIGKILL`
* Выполнить действие по умолчанию, предусмотренное назначением стандартного сигнала POSIX. Как правило, это завершение работы процесса.
* Изменить состояние: sTopped | Running

По умолчанию, все сигналы, кроме `SIGCHILD` (информирование о завершении дочернего процесса) и `SIGURG` (информировании о поступлении TCP-сегмента с приоритетными данными), приводят к завершению работы процесса.

Если процесс был завершён с помощью сигнала, а не с ипользованием системного вызова `exit` то для него считается не определенным код возврата. Родительский процесс может отследить эту ситуацию, используюя макросы `WIFSIGNALED` и `WTERMSIG`
```
pid_t child = ...
...
int status;
waitpid(child, &status, 0);
if (WIFEXITED(status)) {
    // дочерний процесс был завершён через exit
    int code = WEXITSTATUS(status); // код возврата
}
if (WIFSIGNALED(status)) {
    // дочерний процесс был завершёл сигналом
    int signum = WTERMSIG(status); // номер сигнала
}
```
Отправить сигнал любому процессу можно с помощью команды `kill` По умолчанию отправляется сигнал `SIGTERM` но можно указать в качестве опции, какой именно сигнал нужно отправить. Кроме того, некоторые сигналы отправляются терминалом, например *Ctrl+C* посылает сигнал `SIGINT` а *Ctrl+\* - сигнал `SIGQUIT`

Сигналы:
|  Номер  |  Имя   | По умолчанию  |     Описание     |
| :---:   | :----: | :-----------: | :--------------: |
|    1    | SIGHUP |     Term      | обрыв соединения |
